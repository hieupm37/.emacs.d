#+TITLE: Emacs configuration
#+AUTHOR: hieupm37
#+EMAIL: hieupm37@gmail.com

* Basic

+ Hide minor mode in modeline with diminish
#+begin_src emacs-lisp
(my/external-package 'diminish
  (diminish 'eldoc))
#+end_src

+ Disable some unused default functions to prevent mistakenly invoking by keyboard.
#+begin_src emacs-lisp
(dolist (cmd '(narrow-to-region
               upcase-region
               downcase-region
               dired-find-alternate-file
               narrow-to-page
               set-goal-column
               scroll-left
               scroll-right))
  (put cmd 'disabled nil))
(put 'suspend-frame 'disabled t)
(put 'overwrite-mode 'disabled t)

(define-key global-map (kbd "<insert>") nil)
(define-key global-map (kbd "C-z") nil)
(define-key global-map (kbd "C-x C-z") nil)
(define-key global-map (kbd "C-h h") nil)
(define-key global-map (kbd "M-`") nil)
#+end_src

+ Don't ring a bell when error happens
#+begin_src emacs-lisp
(setq ring-bell-function #'ignore)
#+end_src

+ Open scratch buffer instead of welcome at launch.
#+begin_src emacs-lisp
(setq initial-buffer-choice t)  ; open *scratch* buffer at startup.
#+end_src

+ Move custom file to temporary file to make init.el clean
#+begin_src emacs-lisp
(my/builtin-package 'cus-edit
  (setq custom-file (make-temp-file "emacs-custom-")))
#+end_src

* Buffer configuration

+ Move around with ace-window
#+begin_src emacs-lisp
(my/external-package 'ace-window
  (define-key global-map (kbd "M-o") #'ace-window))
#+end_src

+ Copy buffer file name to clipboard. The copied result is relative with project root path.

#+begin_src emacs-lisp
(defun my/copy-filename-to-clipboard (&optional arg)
  "Copy the current buffer file name to clipboard.
With \\[universal-argument], copy relative path to project root."
  (interactive "P")
  (let ((filename (if (eq major-mode 'dired-mode)
                      default-directory
                    (buffer-file-name)))
        (project-root (or (vc-root-dir)
                          (locate-dominating-file "." ".git"))))
    (when (and arg project-root)
      (setq filename (file-relative-name filename project-root)))
    (when filename
      (kill-new filename)
      (message "Copied %s to clipboard." filename))))

(define-key global-map (kbd "<f2>") #'my/copy-filename-to-clipboard)
#+end_src

+ Rename current buffer and its file name.

#+begin_src emacs-lisp
(defun my/rename-file-and-buffer ()
  "Rename current buffer and its file if avaiable."
  (interactive)
  (let ((filename (buffer-file-name)))
    (if (not (and filename (file-exists-p filename)))
        (rename-buffer (read-from-minibuffer "New name: " (buffer-name)))
      (let* ((new-name (read-from-minibuffer "New name: " filename))
             (containing-dir (file-name-directory new-name)))
        (cond
         ((vc-backend filename) (vc-rename-file filename new-name))
         (t
          (rename-file filename new-name t)
          (set-visited-file-name new-name t t)))))))

(define-key global-map (kbd "<f3>") #'my/rename-file-and-buffer)
#+end_src

+ Unique names for buffers

#+begin_src emacs-lisp
(my/builtin-package 'uniquify
  (setq uniquify-buffer-name-style 'forward)
  (setq uniquify-strip-common-suffix t)
  (setq uniquify-after-kill-buffer-p t))
#+end_src

+ Auto reload buffer if file changed

#+begin_src emacs-lisp
(my/builtin-package 'autorevert
  (setq auto-revert-verbose t)
  (add-hook 'after-init-hook #'global-auto-revert-mode))
#+end_src

+ Goto actionable beginning and end of buffers

#+begin_src emacs-lisp
(my/external-package 'beginend
  ;; Hide this mode from modeline
  (diminish 'beginend-global-mode)
  (dolist (mode beginend-modes) (diminish (cdr mode)))
  (beginend-global-mode))
#+end_src

+ Goto last change positions

#+begin_src emacs-lisp
(my/external-package 'goto-last-change
  (define-key global-map (kbd "C-z") #'goto-last-change))
#+end_src

** ibuffer configuration

#+begin_src emacs-lisp
(my/builtin-package 'ibuffer
  (setq ibuffer-expert t)
  (setq ibuffer-display-summary nil)
  (setq ibuffer-use-other-window nil)
  (setq ibuffer-show-empty-filter-groups nil)
  (setq ibuffer-movement-cycle nil)
  (setq ibuffer-default-sorting-mode 'filename/process)
  (setq ibuffer-use-header-line t)
  (setq ibuffer-default-shrink-to-minimum-size nil)
  (setq ibuffer-formats
        '((mark modified read-only locked " "
                (name 30 30 :left :elide)
                " "
                (size 9 -1 :right)
                " "
                (mode 16 16 :left :elide)
                " " filename-and-process)
          (mark " "
                (name 16 -1)
                " " filename)))
  (setq ibuffer-saved-filter-groups nil)
  (setq ibuffer-old-time 48)

  (add-hook 'ibuffer-mode-hook #'hl-line-mode)

  (define-key global-map (kbd "C-x C-b") #'ibuffer)

  (define-key ibuffer-mode-map (kbd "* f") #'ibuffer-mark-by-file-name-regexp)
  (define-key ibuffer-mode-map (kbd "* g") #'ibuffer-mark-by-content-regexp)
  (define-key ibuffer-mode-map (kbd "* n") #'ibuffer-mark-by-name-regexp)
  (define-key ibuffer-mode-map (kbd "s n") #'ibuffer-do-sort-by-alphabetic)
  (define-key ibuffer-mode-map (kbd "/ g") #'ibuffer-filter-by-content))
#+end_src

+ Extend ibuffer command for VC

#+begin_src emacs-lisp
(my/external-package 'ibuffer-vc
  (define-key ibuffer-mode-map (kbd "/ V") #'ibuffer-vc-set-filter-groups-by-vc-root)
  (define-key ibuffer-mode-map (kbd "/ <deletechar>") #'ibuffer-clear-filter-groups))
#+end_src


* Completions

** Find matching with orderless

#+begin_src emacs-lisp
(my/external-package 'orderless
  (defun my/orderless-literal-dispatcher (pattern _index _total)
    "Literal style dispatcher using equal sign as a suffix."
    (when (string-suffix-p "=" pattern)
      `(orderless-literal . ,(substring pattern 0 -1))))

  (defun my/orderless-initialism-dispatcher (pattern _index _total)
    "Leading initalism dispatcher using comma sign as a suffix."
    (when (string-suffix-p "," pattern)
      `(orderless-initialism . ,(substring pattern 0 -1))))

  (setq orderless-matching-styles
        '(orderless-prefixes
          orderless-literal
          orderless-initialism
          orderless-regexp
          orderless-flex))
  (setq orderless-style-dispatchers
        '(my/orderless-literal-dispatcher
          my/orderless-initialism-dispatcher))

  (setq completion-styles '(partial-completion substring flex orderless)))
#+end_src

** Narrowing selections with vertico

#+begin_src emacs-lisp
(my/external-package 'vertico
  (setq vertico-cycle t)

  (defun my/up-directory (arg)
    "Move up a directory (delete backwards to /)."
    (interactive "p")
    (if (string-match-p "/." (minibuffer-contents))
        (zap-up-to-char (- arg) ?/)
      (delete-minibuffer-contents)))

  (define-key vertico-map (kbd "C-j") #'vertico-exit-input)
  (define-key vertico-map (kbd "<C-backspace>") #'my/up-directory)

  (vertico-mode 1))
#+end_src

** Add more information to completion candidates with marginalia

#+begin_src emacs-lisp
(my/external-package 'marginalia
  (setq marginalia-max-relative-age 0)
  (marginalia-mode 1))
#+end_src

** Enrich completion with consult

#+begin_src emacs-lisp
(my/external-package 'consult
  (setq consult-narrow-key ">")
  (setq completion-in-region-function #'consult-completion-in-region)
  ;; Use completing-read-multiple provided by consult
  (advice-add #'completing-read-multiple
              :override #'consult-completing-read-multiple)

  (defun my/consult-project-root ()
    "Returns patht to project or `default-directory'."
    (or (vc-root-dir)
        (locate-dominating-file "." ".git")
        default-directory))
  (setq consult-project-root-function #'my/consult-project-root)

  ;; Setup key bindings
  ;; Using consult's complex-command instead of builtin
  (global-set-key [remap repeat-complex-command] #'consult-complex-command)

  (global-set-key (kbd "C-x b") #'consult-buffer)
  (global-set-key (kbd "C-x 4 b") #'consult-buffer-other-window)
  (global-set-key (kbd "C-x 5 b") #'consult-buffer-other-frame)
  (global-set-key (kbd "C-y") #'yank)
  (global-set-key (kbd "M-y") #'consult-yank-pop)
  (global-set-key (kbd "<help> a") #'consult-apropos)

  (global-set-key (kbd "M-g e") #'consult-compile-error)
  (global-set-key (kbd "M-g g") #'consult-goto-line)
  (global-set-key (kbd "M-g M-g") #'consult-goto-line)
  (global-set-key (kbd "M-g o") #'consult-outline)
  (global-set-key (kbd "M-g m") #'consult-mark)
  (global-set-key (kbd "M-g M") #'consult-global-mark)
  (global-set-key (kbd "M-g i") #'consult-imenu)
  (global-set-key (kbd "M-g M-i") #'consult-imenu)
  (global-set-key (kbd "M-g I") #'consult-project-imenu)

  (global-set-key (kbd "M-s f") #'consult-find)
  (global-set-key (kbd "M-s L") #'consult-locate)
  (global-set-key (kbd "M-s g") #'consult-git-grep)
  (global-set-key (kbd "M-s G") #'consult-grep)
  (global-set-key (kbd "M-s r") #'consult-ripgrep)
  (global-set-key (kbd "M-s l") #'consult-line)
  (global-set-key (kbd "M-s m") #'consult-multi-occur)
  (global-set-key (kbd "M-s k") #'consult-keep-lines)
  (global-set-key (kbd "M-s u") #'consult-focus-lines)
  (global-set-key (kbd "M-s e") #'consult-isearch-history)
  (define-key isearch-mode-map (kbd "M-s e") #'consult-isearch-history))
#+end_src

+ Change directory path while inputing file path

#+begin_src emacs-lisp
(my/external-package 'consult-dir
  (define-key global-map (kbd "C-x C-d") #'consult-dir)
  (define-key vertico-map (kbd "C-x C-d") #'consult-dir))
#+end_src

** Dynamic word completions

#+begin_src emacs-lisp
(my/builtin-package 'dabbrev
  (setq dabbrev-abbrev-char-regexp "\\sw\\|\\s_")
  (setq dabbrev-abbrev-skip-leading-regexp "[$*/=~']")
  (setq dabbrev-backward-only nil)
  (setq dabbrev-case-distinction 'case-replace)
  (setq dabbrev-case-fold-search nil)
  (setq dabbrev-case-replace 'case-replace)
  (setq dabbrev-check-other-buffers t)
  (setq dabbrev-eliminate-newlines t)
  (setq dabbrev-upcase-means-case-search t)
  (global-set-key (kbd "C-M-/") #'dabbrev-completion))
#+end_src

** Hippie expand

#+begin_src emacs-lisp
(my/builtin-package 'hippie-exp
  (setq hippie-expand-try-functions-list
        '(try-expand-dabbrev
          try-expand-dabbrev-all-buffers
          try-expand-all-abbrevs
          try-expand-list
          try-expand-line
          try-complete-lisp-symbol-partially
          try-complete-lisp-symbol
          try-complete-file-name-partially
          try-complete-file-name))
  (setq hippie-expand-verbose t)
  (setq hippie-expand-dabbrev-skip-space nil)
  (setq hippie-expand-dabbrev-as-symbol t)
  (setq hippie-expand-no-restriction t)
  (define-key global-map (kbd "M-/") #'hippie-expand))
#+end_src

** Completion for recent files and directories

#+begin_src emacs-lisp
(my/builtin-package 'recentf
  (setq recentf-save-file (locate-user-emacs-file "recentf"))
  (setq recentf-max-saved-items 200)
  (setq recentf-exclude '(".gz" ".xz" ".zip" "/elpa/" "/ssh:" "/sudo:"))

  (defun my/recentf-keep-predicate (file)
    "Additional conditions for saving FILE in `recentf-list'."
    (cond
     ((file-directory-p file) (file-readable-p file))))

  (add-to-list 'recentf-keep #'my/recentf-keep-predicate)

  (defun my/recentf-select-files ()
    "Select item from `recentf-list' using completion."
    (interactive)
    (let* ((files (mapcar 'abbreviate-file-name recentf-list))
           (f (completing-read "Recent file: " files nil t)))
      (find-file f)))

  (add-hook 'after-init-hook #'recentf-mode)
  (define-key global-map (kbd "C-x C-r") #'my/recentf-select-files))
#+end_src


* Searching

** Basic config

#+begin_src emacs-lisp
(my/builtin-package 'isearch
  (setq search-highlight t)
  (setq search-whitespace-regexp ".*?")
  (setq isearch-lax-whitespace t)
  (setq isearch-regexp-lax-whitespace nil)
  (setq isearch-lazy-highlight t)
  (setq isearch-lazy-count t)
  (setq lazy-count-prefix-format nil)
  (setq lazy-count-suffix-format " (%s/%s)")
  (setq isearch-yank-on-move 'shift)
  (setq isearch-allow-scroll 'unlimited))
#+end_src

** Enrich search commands

#+begin_src emacs-lisp
(defun my/isearch-replace-symbol-at-point ()
  "Replace the symbol at point."
  (interactive)
  (isearch-forward-symbol-at-point)
  (isearch-query-replace-regexp))

(defmacro my/isearch-occurrence (name edge &optional doc)
  "Construct function for moving `isearch' occurence."
  `(defun ,name (&optional arg)
     ,doc
     (interactive "p")
     (let ((x (or arg 1))
           (command (intern (format "isearch-%s-of-buffer" ,edge))))
       (isearch-forward-symbol-at-point)
       (funcall command x))))

(my/isearch-occurrence
 my/isearch-beginning-of-buffer
 "beginning"
 "Run `isearch-beginning-of-buffer' for the symbol at point.")

(my/isearch-occurrence
 my/isearch-end-of-buffer
 "end"
 "Run `isearch-end-of-buffer' for the symbol at point.")

(global-set-key (kbd "M-s %") #'my/isearch-replace-symbol-at-point)
(global-set-key (kbd "M-s M-<") #'my/isearch-beginning-of-buffer)
(global-set-key (kbd "M-s M->") #'my/isearch-end-of-buffer)

(define-key isearch-mode-map (kbd "C-g") #'isearch-cancel)
(define-key isearch-mode-map (kbd "M-/") #'isearch-complete)
#+end_src

* Editing

+ Prefer unix encoding when create new file
#+begin_src emacs-lisp
(prefer-coding-system 'utf-8-unix)
#+end_src

+ Disable bidirectional writing might improve Emacs responsive in some cases.
#+begin_src emacs-lisp
(setq-default bidi-paragraph-direction 'left-to-right)
(setq bidi-inhibit-bpa t)
#+end_src

+ Improve handling very long lines in Emacs
#+begin_src emacs-lisp
(my/builtin-package 'so-long
  (global-so-long-mode 1))
#+end_src

+ Typed text replaces the selection
#+begin_src emacs-lisp
(my/builtin-package 'delsel
  (add-hook 'after-init-hook #'delete-selection-mode))
#+end_src

+ Save existing clipboard text into the kill-ring before replacing it.
  It can be retrived via C-y or M-y.

#+begin_src emacs-lisp
(setq save-interprogram-paste-before-kill t)
#+end_src

+ Auto add empty newline for file ending when save.

#+begin_src emacs-lisp
(setq mode-require-final-newline t)
#+end_src

+ Prefer spaces over tabs

#+begin_src emacs-lisp
(setq-default tab-width 2)
(setq-default indent-tabs-mode nil)
#+end_src

+ First tab is indent and second tab is completion.

#+begin_src emacs-lisp
(setq-default tab-always-indent 'complete)
#+end_src

+ Delete trailing whitespaces before saving

#+begin_src emacs-lisp
(add-hook 'before-save-hook #'delete-trailing-whitespace)
#+end_src

** General commands for lines

#+begin_src emacs-lisp
(defun my/new-line-below ()
  "Create an empty new line below the current one. Indent if mode is auto indent."
  (interactive)
  (end-of-line)
  (newline-and-indent))

(defun my/new-line-above ()
  "Create an empty line above the current one. Indent if mode is auto indent."
  (interactive)
  (beginning-of-line)
  (newline-and-indent)
  (forward-line -1)
  (indent-according-to-mode))

(define-key global-map (kbd "M-SPC") #'cycle-spacing)
(define-key global-map (kbd "<C-return>") #'my/new-line-below)
(define-key global-map (kbd "<C-S-return>") #'my/new-line-above)
#+end_src

** Mark objects

#+begin_src emacs-lisp
(defun my/mark-symbol (&optional arg allow-extend)
  "Mark symbols at point."
  (interactive "P\np")
  (cond ((and allow-extend
              (or (and (eq last-command this-command) (mark t))
                  (region-active-p)))
         (setq arg (if arg (prefix-numeric-value arg)
                     (if (< (mark) (point)) -1 1)))
         (set-mark
          (save-excursion
            (goto-char (mark))
            (forward-symbol arg)
            (point))))
        (t
         (let ((bounds (bounds-of-thing-at-point 'symbol)))
           (unless (consp bounds)
             (user-error "No symbol at point."))
           (if (>= (prefix-numeric-value arg) 0)
               (goto-char (car bounds))
             (goto-char (cdr bounds)))
           (push-mark
            (save-excursion
              (forward-symbol (prefix-numeric-value arg))
              (point)))
           (activate-mark)))))

(defun my/mark-sexp-backward (&optional arg)
  "Mark previous or ARGs balanced expressions."
  (interactive "P")
  (if arg
      (mark-sexp (- arg) t)
    (mark-sexp (- 1) t)))

(defun my/mark-dwim (&optional arg)
  "Mark symbol or balanced expression at point."
  (interactive "P")
  (cond
   ((symbol-at-point)
    (my/mark-symbol arg t))
   ((eq (point) (cdr (bounds-of-thing-at-point 'sexp)))
    (my/mark-sexp-backward arg))
   (t
    (mark-sexp arg t))))

(define-key global-map (kbd "C-M-SPC") #'my/mark-dwim)
#+end_src

* History and state

** Save and restore desktop session

#+begin_src emacs-lisp
(my/builtin-package 'desktop
  (setq desktop-auto-save-timeout 300)  ; 5 min
  (setq desktop-dirname user-emacs-directory)
  (setq desktop-base-file-name "desktop")
  (setq desktop-load-locked-desktop t) ; always load
  (setq desktop-missing-file-warning nil)
  (setq desktop-restore-eager 0) ; all files are lazy restored
  (setq desktop-restore-frames nil) ; don't restore frame

  ;; Don't save for these mode
  (add-to-list 'desktop-modes-not-to-save 'dired-mode)

  (desktop-save-mode 1))
#+end_src

** Save minibuffer history

#+begin_src emacs-lisp
(my/builtin-package 'savehist
  (setq savehist-file (locate-user-emacs-file "savehist"))

  (add-hook 'after-init-hook #'savehist-mode))
#+end_src

** Record cursor positions

#+begin_src emacs-lisp
(my/builtin-package 'saveplace
  (setq save-place-file (locate-user-emacs-file "saveplace"))
  (save-place-mode 1))
#+end_src

** Move backup files to central location

#+begin_src emacs-lisp
(defvar my/backup-dir (expand-file-name "backup/" user-emacs-directory))
(setq backup-directory-alist `(("." . ,my/backup-dir)))
(setq backup-by-copying t)
(setq version-control t)
(setq delete-old-versions t)
(setq create-lockfiles nil)
#+end_src

* UI configuration

** Basic setup

+ Format frame title with buffer's file path.

#+begin_src emacs-lisp
(setq frame-title-format
      '("Emacs - " (:eval (if (buffer-file-name)
                              (abbreviate-file-name (buffer-file-name))
                            "%b"))))
#+end_src

+ Show column number in modeline

#+begin_src emacs-lisp
(add-hook 'after-init-hook #'column-number-mode)
#+end_src

+ Refine window boders

#+begin_src emacs-lisp
(setq window-divider-default-right-width 1)
(setq window-divider-default-bottom-width 1)
(setq window-divider-default-places 'right-only)
(add-hook 'after-init-hook #'window-divider-mode)
#+end_src

+ Don't use blink cursor

#+begin_src emacs-lisp
(setq-default cursor-type 'box)
(blink-cursor-mode -1)
#+end_src

+ Keep mouse away input cursor

#+begin_src emacs-lisp
(my/builtin-package 'avoid
  (mouse-avoidance-mode 'animate))
#+end_src

+ Sorter yes no question

#+begin_src emacs-lisp
(if (boundp 'use-short-answers)
    (setq use-short-answers t)
  (advice-add 'yes-or-no-p :override #'y-or-n-p))
#+end_src

** Font

#+begin_src emacs-lisp
;; Setup font size based on the DPI of screen
(defun my/screen-dpi-of-frame (&optional frame)
  "Get the DPI of the frame (or the current if nil)."
  (cl-flet ((pyth (lambda (w h)
                    (sqrt (+ (* w w) (* h h)))))
            (mm2in (lambda (mm)
                     (/ mm 25.4))))
    (let* ((atts (frame-monitor-attributes frame))
           (pxw (cl-fourth (assoc 'geometry atts)))
           (pxh (cl-fifth (assoc 'geometry atts)))
           (pxd (pyth pxw pxh))
           (mmw (cl-second (assoc 'mm-size atts)))
           (mmh (cl-third (assoc 'mm-size atts)))
           (mmd (pyth mmw mmh)))
      (/ pxd (mm2in mmd)))))

(defun my/screen-dpi ()
  "Tell the DPI of current screen."
  (interactive)
  (message "Your DPI is %s" (my/screen-dpi-of-frame (selected-frame))))

(defun my/setup-font ()
  "Setup font for current frame."
  (interactive)
  (let* ((dpi (my/screen-dpi-of-frame (selected-frame)))
         (font-size (cond
                     ((< dpi 96) 12)
                     ((< dpi 160) 12)
                     (t 16))))
    (if (eq system-type 'windows-nt)
        (set-frame-font (format "Consolas %s" font-size))
      (set-frame-font (format "Source Code Pro %s" font-size)))))

(add-hook 'after-init-hook #'my/setup-font)
#+end_src

** Theme

#+begin_src emacs-lisp
;; Configure the Modus Themes' appearance
(setq modus-themes-mode-line '(accented borderless)
      ; modus-themes-bold-constructs t
      modus-themes-italic-constructs t
      modus-themes-fringes 'subtle
      modus-themes-tabs-accented t
      modus-themes-paren-match '(bold intense)
      modus-themes-prompts '(bold intense)
      modus-themes-completions 'opinionated
      modus-themes-org-blocks 'tinted-background
      modus-themes-scale-headings t
      modus-themes-region '(bg-only)
      modus-themes-headings
      '((1 . (rainbow overline background 1.4))
        (2 . (rainbow background 1.3))
        (3 . (rainbow bold 1.2))
        (t . (semilight 1.1))))

;; Load the dark theme by default
(load-theme 'modus-vivendi t)
#+end_src

* Version control

** Basic setup

#+begin_src emacs-lisp
(my/builtin-package 'vc
  (setq vc-follow-symlinks t))
#+end_src

** Magit setup

#+begin_src emacs-lisp
(my/external-package 'magit
  (setq magit-define-global-key-bindings nil)

  ;; Show fine differences for current hunk only.
  (setq magit-diff-refine-hunk t)

  (global-set-key (kbd "C-x g") #'magit-status)
  (global-set-key (kbd "C-x M-g") #'magit-dispatch)
  (global-set-key (kbd "C-c g") #'magit-file-dispatch))
#+end_src

** Use ssh-agency to remember passphrase

#+begin_src emacs-lisp
(my/external-package 'ssh-agency
  (setenv "SSH_ASKPASS" "git-gui--askpass"))
#+end_src

* Programming

** Basic setup

+ Recognize subword in camel-case name

#+begin_src emacs-lisp
(my/builtin-package 'subword
  (diminish 'subword-mode)  ; Hide this in modeline
  (add-hook 'prog-mode-hook #'subword-mode))
#+end_src

+ Enrich comment line or region

#+begin_src emacs-lisp
(my/builtin-package 'newcomment
  (setq comment-empty-lines t)
  (setq comment-fill-column nil)
  (setq comment-multi-line t)
  (setq commnet-style 'multi-line)

  (defun my/comment-dwim (&optional arg)
    (interactive "P")
    (if (use-region-p)
        (comment-dwim arg)
      (save-excursion
        (comment-line arg))))

  (define-key global-map (kbd "C-x C-;") #'my/comment-dwim))
#+end_src

** UI setup for programming

+ Visualize matching paren

#+begin_src emacs-lisp
(my/builtin-package 'paren
  (add-hook 'after-init-hook #'show-paren-mode))
#+end_src

+ Highlight TODO keywords

#+begin_src emacs-lisp
(my/external-package 'hl-todo
  (add-hook 'prog-mode-hook #'hl-todo-mode))
#+end_src

+ Show indicator at 80 column in prog modes.

#+begin_src emacs-lisp
(my/builtin-package 'display-fill-column-indicator
  (setq-default fill-column 80)
  (add-hook 'prog-mode-hook #'display-fill-column-indicator-mode))
#+end_src

** C++ development

+ Auto-detect mode for header file

#+begin_src emacs-lisp
;; Ref: https://github.com/hlissner/doom-emacs/blob/develop/modules/lang/cc/autoload.el
(defvar my/+cc-default-header-file-mode 'c++-mode
  "Fallback major mode for header files if all heuristics fail.")

(defun my/+cc--re-search-for (regexp)
  (save-excursion
    (save-restriction
      (save-match-data
        (widen)
        (goto-char (point-min))
        (re-search-forward regexp magic-mode-regexp-match-limit t)))))

(defun my/+cc-c-c++-objc-mode ()
  "Uses heuristics to detect `c-mode', `objc-mode' or `c++-mode'.
1. Checks if there are nearby cpp/cc/m/mm files with the same name.
2. Checks for ObjC and C++-specific keywords and libraries.
3. Falls back to `+cc-default-header-file-mode', if set.
4. Otherwise, activates `c-mode'.
This is meant to replace `c-or-c++-mode' (introduced in Emacs 26.1), which
doesn't support specification of the fallback mode and whose heuristics are
simpler."
  (let ((base (file-name-sans-extension (buffer-file-name (buffer-base-buffer)))))
    (cond ((file-exists-p (or (concat base ".cpp")
                              (concat base ".cc")))
           (c++-mode))
          ((or (file-exists-p (or (concat base ".m")
                                  (concat base ".mm")))
               (my/+cc--re-search-for
                (concat "^[ \t\r]*\\(?:"
                        "@\\(?:class\\|interface\\|property\\|end\\)\\_>"
                        "\\|#import +<Foundation/Foundation.h>"
                        "\\|[-+] ([a-zA-Z0-9_]+)"
                        "\\)")))
           (objc-mode))
          ((my/+cc--re-search-for
            (let ((id "[a-zA-Z0-9_]+") (ws "[ \t\r]+") (ws-maybe "[ \t\r]*"))
              (concat "^" ws-maybe "\\(?:"
                      "using" ws "\\(?:namespace" ws "std;\\|std::\\)"
                      "\\|" "namespace" "\\(?:" ws id "\\)?" ws-maybe "{"
                      "\\|" "class"     ws id ws-maybe "[:{\n]"
                      "\\|" "template"  ws-maybe "<.*>"
                      "\\|" "#include"  ws-maybe "<\\(?:string\\|iostream\\|map\\)>"
                      "\\)")))
           (c++-mode))
          ((functionp my/+cc-default-header-file-mode)
           (funcall my/+cc-default-header-file-mode))
          ((c-mode)))))

(add-to-list 'auto-mode-alist '("\\.h\\'" . my/+cc-c-c++-objc-mode))
(add-to-list 'auto-mode-alist '("\\.mm\\'" . objc-mode))
#+end_src

+ Toggle between source and header file for c++ mode.
  TODO: Extend for objc mode.

#+begin_src emacs-lisp
  (my/builtin-package 'find-file
    (defmacro my/cc-other-file (name fff &optional doc)
      "Toggle source/header file."
      `(defun ,name ()
         ,doc
         (interactive)
         (let* ((command (intern ,fff))
                (buf (current-buffer))
                (name (file-name-sans-extension (buffer-file-name)))
                (other-extens
                 (cadr (assoc (concat "\\."
                                      (file-name-extension (buffer-file-name))
                                      "\\'")
                              cc-other-file-alist))))
           (dolist (e other-extens)
             (if (let ((f (concat name e)))
                   (and (file-exists-p f) (funcall command f)))
                 (return))))))
    (my/cc-other-file
     my/cc-other-file-current
     "find-file"
     "Run `find-file' with other cc file.")

    (my/cc-other-file
     my/cc-other-file-other
     "find-file-other-window"
     "Run `find-file-other-window' with other cc file.")

    (my/builtin-package 'cc-mode
      (define-key c++-mode-map (kbd "C-c o") #'my/cc-other-file-current)
      (define-key c++-mode-map (kbd "C-c 4 o") #'my/cc-other-file-other)))
#+end_src

+ Use Google C++ coding styles for c, c++, objc mode.

#+begin_src emacs-lisp
(my/external-package 'google-c-style
  (add-hook 'c-mode-common-hook #'google-set-c-style)
  (add-hook 'c-mode-common-hook #'google-make-newline-indent))
#+end_src

+ Font lock for modern c++

#+begin_src emacs-lisp
(my/external-package 'modern-cpp-font-lock
  (add-hook 'c++-mode-hook #'modern-c++-font-lock-mode))
#+end_src

** js-mode for .js, .ts file

#+begin_src emacs-lisp
(my/builtin-package 'js
  (setq js-indent-level 2)

  (add-to-list 'auto-mode-alist '("\\.js\\'" . js-mode))
  (add-to-list 'auto-mode-alist '("\\.ts\\'" . js-mode)))
#+end_src

** smgl-mode for .html file

#+begin_src emacs-lisp
(my/builtin-package 'sgml-mode
  (setq sgml-basic-offset 2))
#+end_src

** gn-mode for .gni? file

#+begin_src emacs-lisp
(my/external-package 'gn-mode
  (add-to-list 'auto-mode-alist '("\\.gni?\\'" . gn-mode)))
#+end_src

** markdown mode

#+begin_src emacs-lisp
(my/external-package 'markdown-mode
  (setq markdown-command "multimarkdown")

  (add-to-list 'auto-mode-alist '("README\\.md\\'" . gfm-mode)))
#+end_src

** groovy-mode for .groovy file

#+begin_src emacs-lisp
(my/external-package 'groovy-mode
  (add-to-list 'auto-mode-alist '("\\.groovy\\'" . groovy-mode)))
#+end_src

** dotenv-mode for .env file

#+begin_src emacs-lisp
(my/external-package 'dotenv-mode
  (add-to-list 'auto-mode-alist '("\\.env\\..*\\'" . dotenv-mode)))
#+end_src

** restclient mode for HTTP
#+begin_src emacs-lisp
(my/external-package 'restclient)
#+end_src

** bazel mode

#+begin_src emacs-lisp
(my/external-package 'bazel
  (add-to-list 'auto-mode-alist '("\\WORKSPACE\\BUILD.bazel'" . bazel-mode)))
#+end_src

* Org mode configuration

Keyboard bindings table for org mode

| Command                                            | Bindings |
|----------------------------------------------------+----------|
| New section with same level                        | M-RET    |
| Insert source code block                           | C-c C-,  |
| Open/Close editing source code block in new buffer | C-c '    |


#+begin_src emacs-lisp
(require 'org)

;; New section with the same level without spliting line
(setq org-M-RET-may-split-line '((default . nil)))

;; Insert src templates
(setq org-structure-template-alist
      '(("s" . "src")
        ("E" . "src emacs-lisp")
        ("e" . "example")
        ("q" . "quote")))

;; Show invisible region when editing
(setq org-catch-invisible-edits 'show)

(setq org-imenu-depth 7)

;; Edit src block in a new buffer, start with C-c ' and close with C-c ', save with C-x C-s
(setq org-src-window-setup 'current-window)
(setq org-edit-src-persistent-message nil)
(setq org-src-preserve-indentation t)
(setq org-edit-src-content-indentation 0)
#+end_src

** GTD setup

The GTD setup is mostly taken from https://github.com/rougier/emacs-gtd

The steps to do GTD:
1. *Capture* anything across your mind with C-c c or C-c i for inbox.
2. *Clarify* what you've captured into clear and concrete action steps.
   Set schedule with C-c C-s or deadline with C-c C-d. Plain timestamp with C-c .
   Add tags with C-c C-c on headline.
   Estimate with C-c C-x e
3. *Organize* and put everything into right place.
   Refile section with C-c C-w into projects.
4. *Review*, update and revise task lists.
   Change to next action with C-c C-t.
5. *Engage*, work on important stuffs.
   Update progress indicator with C-c C-c on [/].
   Clock in with C-c C-x C-i, clock out with C-c C-x C-o.

Total set of commands for GTD:

| Command                          | Bindigs         | Mode + Where         |
|----------------------------------+-----------------+----------------------|
| Agenda                           | C-c a           | any                  |
| Agenda for today                 | C-c a a         | any                  |
| Capture menu                     | C-c c           | any                  |
| Capture generic TODO (inbox.org) | C-c i (C-c c i) | any                  |
| Add/Remove tag                   | C-c C-c         | org-mode on headline |
| Update progress indicator        | C-c C-c         | org-mode on [/]      |
| Update all progress indicators   | C-u C-c #       | org-mode             |
| Enter estimated effort           | C-c C-x e       | org-mode on headline |
| Refile section                   | C-c C-w         | org-mode on headline |
| Clock in                         | C-c C-x C-i     | org-mode on headline |
| Clock out                        | C-c C-x C-o     | org-mode on headline |
| Plain timestamp                  | C-c .           | org-mode             |
| Scheduled timestamp              | C-c C-s         | org-mode             |
| Deadline timestamp               | C-c C-d         | org-mode             |


Here is the source code.

#+begin_src emacs-lisp
(require 'org)

;; Files
(setq org-directory "~/org")
(setq org-agenda-files '("inbox.org" "notes.org" "projects.org" "agenda.org"))
(setq org-default-notes-file "~/org/notes.org")

;; Capture
(setq org-capture-templates
      `(("i" "Inbox" entry (file "inbox.org")
         ,(concat "* TODO %^{Title}\n"
                  ":PROPERTIES:\n"
                  ":CAPTURED: %U\n"
                  ":END:\n\n"
                  "%i%?"))
        ("n" "Note" entry (file "notes.org")
         ,(concat "* %^{Title}\n"
                  ":PROPERTIES:\n"
                  ":CAPTURED: %U\n"
                  ":END\n\n"
                  "%i%?"))))

(define-key global-map (kbd "C-c c") 'org-capture)

(defun my/org-capture-inbox ()
  "Capture idea directly to inbox.org"
  (interactive)
  (call-interactively 'org-store-link)
  (org-capture nil "i"))

(define-key global-map (kbd "C-c i") 'my/org-capture-inbox)

(defun my/org-capture-no-delete-windows (oldfun args)
  (cl-letf (((symbol-function 'delete-other-windows) 'ignore))
    (apply oldfun args)))

(advice-add 'org-capture-place-template
            :around 'my/org-capture-no-delete-windows)

;; Refile
(require 'org-refile)

(setq org-refile-use-outline-path 'file)
(setq org-outline-path-complete-in-steps nil)
(setq org-refile-targets
      '(("projects.org" :regexp . "\\(?:\\(?:Note\\|Task\\)s\\)")))

;; Automatic save after refilling
(defun my/gtd-save-org-buffers ()
  "Save `org-agenda-files' buffers without user confirmation."
  (interactive)
  (message "Saving org-agenda-files buffers...")
  (save-some-buffers t (lambda ()
                         (when (member (buffer-name) org-agenda-files)
                           t)))
  (message "Saving org-agenda-files buffers... done"))

(defmacro my/ignore-args (func)
  `(lambda (&rest _)
     (funcall ,func)))
(advice-add 'org-refile :after (my/ignore-args #'my/gtd-save-org-buffers))
(advice-add 'org-todo :after (my/ignore-args #'my/gtd-save-org-buffers))

;; TODO
(setq org-todo-keywords
      '((sequence "TODO(t)" "NEXT(n)" "HOLD(h)" "|" "DONE(d)" "CANCEL(c)")))

(setq org-log-done 'time)
(defun my/log-todo-next-creation-date (&rest ignore)
  "Log NEXT creation time in the properties under the key ACTIVATED"
  (when (and (string= (org-get-todo-state) "NEXT")
             (not (org-entry-get nil "ACTIVATED")))
    (org-entry-put nil "ACTIVATED" (format-time-string "[%Y-%m-%d]"))))
(add-hook 'org-after-todo-state-change-hook #'my/log-todo-next-creation-date)

;; Agenda

(define-key global-map (kbd "C-c a") 'org-agenda)

;; Some configurations for agenda view
(setq org-agenda-hide-tags-regexp ".")
(setq org-agenda-window-setup 'current-window)
(setq org-deadline-warning-days 5)
(setq org-agenda-skip-scheduled-if-deadline-is-shown t)
(setq org-agenda-skip-timestamp-if-deadline-is-shown t)
(setq org-agenda-skip-deadline-prewarning-if-scheduled t)
(setq org-scheduled-past-days 365)
(setq org-deadline-warning-days 365)
(setq org-agenda-current-time-string
      "Now -·-·-·-·-·-·-")
(setq org-agenda-time-grid
      '((daily today require-timed)
        (0600 0700 0800 0900 1000 1100
              1200 1300 1400 1500 1600
              1700 1800 1900 2000 2100)
        " ....." "-----------------"))
(setq org-agenda-prefix-format
      '((agenda . " %i %-12:c%?-12t% s")
        (todo   . " %i %-12:c")
        (tags   . " %i %-12:c")
        (search . " %i %-12:c")))
;; Global todo list
(setq org-agenda-todo-ignore-with-date t)
(setq org-agenda-todo-ignore-timestamp t)
(setq org-agenda-todo-ignore-scheduled t)
(setq org-agenda-todo-ignore-deadlines t)
(setq org-agenda-todo-ignore-time-comparison-use-seconds t)

;; GTD agenda
(setq org-agenda-custom-commands
      '(("g" "Get Things Done (GTD)"
         ((agenda ""
                  ((org-agenda-skip-function
                    '(org-agenda-skip-entry-if 'deadline))
                   (org-deadline-warning-days 0)))
          (todo "NEXT"
                ((org-agenda-skip-function
                  '(org-agenda-skip-entry-if 'deadline))
                 (org-agenda-prefix-format "  %i %-12:c [%e] ")
                 (org-agenda-overriding-header "\nTasks\n")))
          (agenda nil
                  ((org-agenda-entry-types '(:deadline))
                   (org-agenda-format-date "")
                   (org-deadline-warning-days 7)
                   (org-agenda-skip-function
                    '(org-agenda-skip-entry-if 'notregexp "\\* NEXT"))
                   (org-agenda-overriding-header "\nDeadlines")))
          (tags-todo "inbox"
                     ((org-agenda-prefix-format "  %?-12t% s")
                      (org-agenda-overriding-header "\nInbox\n")))
          (tags "CLOSED>=\"<today>\""
                ((org-agenda-overriding-header "\nCompleted today\n")))))))
#+end_src

* Elfeed for RSS

#+begin_src emacs-lisp
(my/external-package 'elfeed
  (setq elfeed-db-directory (concat user-emacs-directory "elfeed/"))
  (setq elfeed-search-title-max-width 100)
  (setq elfeed-show-unique-buffers t)
  (setq elfeed-feeds
        '(("https://news.ycombinator.com/rss" news)
          ("http://blog.chromium.org/atom.xml" blog chromium)
          ("https://chromereleases.googleblog.com/feeds/posts/default" release chromium)
          ("https://developer.chrome.com/feeds/blog.xml" chrome)
          ("https://blog.google/products/chrome/rss" blog chrome)
          ("https://blogs.windows.com/msedgedev/feed/" blog edge)
          ("https://randomascii.wordpress.com/feed/" blog)
          ("http://www.fluentcpp.com/feed/" cpp blog)
          ("https://www.joelonsoftware.com/feed/" software blog)
          ("https://herbsutter.com/feed/" cpp blog)
          ("http://www.modernescpp.com/index.php?format=feed" cpp blog)
          ("https://googleprojectzero.blogspot.com/feeds/posts/default" blog security)
          ("https://emacsredux.com/atom.xml" blog emacs)))

  (defvar my/saved-window-configuration nil
    "Current window configuration before opening elfeed search.")

  (defun my/elfeed-dwim ()
    "Open elfeed search buffer in maximized window."
    (interactive)
    (if (one-window-p)
        (elfeed)
      (setq my/saved-window-configuration (current-window-configuration))
      (delete-other-windows)
      (elfeed)))

  (defun my/elfeed-search-quit-dwim ()
    "Close search buffer, restore saved window configuration."
    (interactive)
    (elfeed-search-quit-window)
    (when my/saved-window-configuration
      (set-window-configuration my/saved-window-configuration)))

  (defun my/elfeed-entry-quit-dwim ()
    "Kill entry buffer and switch back to *elfeed-search* buffer."
    (interactive)
    (unless (one-window-p)
      (delete-other-windows))
    (elfeed-kill-buffer)
    (switch-to-buffer "*elfeed-search*"))

  (define-key global-map (kbd "C-x w") #'my/elfeed-dwim)

  (define-key elfeed-search-mode-map (kbd "q") #'my/elfeed-search-quit-dwim)
  (define-key elfeed-show-mode-map (kbd "q") #'my/elfeed-entry-quit-dwim))
#+end_src

* Tie objects - actions with Embark

Thanks to https://karthinks.com/software/fifteen-ways-to-use-embark/

#+begin_src emacs-lisp
(my/external-package 'embark
  ;; Optionally replace the key help with a completing-read interface
  (setq prefix-help-command #'embark-prefix-help-command)

  ;; Hide the mode line of the Embark live/completions buffers
  (add-to-list 'display-buffer-alist
               '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                 nil
                 (window-parameters (mode-line-format . none))))

  (require 'ace-window)
  (defmacro my/embark-ace-action (fn)
    `(defun ,(intern (concat "my/embark-ace-" (symbol-name fn))) ()
       (interactive)
       (with-demoted-errors "%s"
         (let ((aw-dispatch-always t))
           (aw-switch-to-window (aw-select nil))
           (call-interactively (symbol-function ',fn))))))

  (my/embark-ace-action find-file)
  (my/embark-ace-action switch-to-buffer)
  (my/embark-ace-action bookmark-jump)

  (define-key embark-file-map (kbd "o") #'my/embark-ace-find-file)
  (define-key embark-buffer-map (kbd "o") #'my/embark-ace-switch-to-buffer)
  (define-key embark-bookmark-map (kbd "o") #'my/embark-ace-bookmark-jump)

  (define-key global-map (kbd "C-,") #'embark-act)

  (require 'vertico)
  (define-key vertico-map (kbd "C-M-,") #'embark-export))
#+end_src

Integration with embark and consult

#+begin_src emacs-lisp
(my/external-package 'embark-consult)
#+end_src
